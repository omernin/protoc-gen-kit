// Code generated by protoc-gen-kit. DO NOT EDIT.
// source: greeter.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	math "math"
)

import (
	context "context"
	kitendpoint "github.com/go-kit/kit/endpoint"
	kitlog "github.com/go-kit/kit/log"
	kitgrpc "github.com/go-kit/kit/transport/grpc"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/oklog/oklog/pkg/group"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context

//////////////////////////////////////////////////////////
// Go-kit middlewares for Greeter service
//////////////////////////////////////////////////////////

type GreeterMiddleware func(GreeterServer) GreeterServer

type greeterLoggingMiddleware struct {
	logger kitlog.Logger
	next   GreeterServer
	UnimplementedGreeterServer
}

// GreeterLoggingMiddleware takes a logger as a dependency
// and returns a GreeterServer Middleware.
func GreeterLoggingMiddleware(logger kitlog.Logger) GreeterMiddleware {
	return func(next GreeterServer) GreeterServer {
		return &greeterLoggingMiddleware{logger: logger, next: next}
	}
}
func (l greeterLoggingMiddleware) Hello(ctx context.Context, request *HelloRequest) (response *HelloResponse, err error) {
	defer func(begin time.Time) {
		l.logger.Log(
			"method", "Hello",
			"request", request,
			"response", response,
			"error", err,
			"took", time.Since(begin))
	}(time.Now())
	return l.next.Hello(ctx, request)
}
func (l greeterLoggingMiddleware) Goodbye(ctx context.Context, request *GoodbyeRequest) (response *GoodbyeResponse, err error) {
	defer func(begin time.Time) {
		l.logger.Log(
			"method", "Goodbye",
			"request", request,
			"response", response,
			"error", err,
			"took", time.Since(begin))
	}(time.Now())
	return l.next.Goodbye(ctx, request)
}

type greeterValidationMiddleware struct {
	logger kitlog.Logger
	next   GreeterServer
	UnimplementedGreeterServer
}

// GreeterValidationMiddleware takes a logger as a dependency
// and returns a GreeterServer Middleware.
func GreeterValidationMiddleware(logger kitlog.Logger) GreeterMiddleware {
	return func(next GreeterServer) GreeterServer {
		return &greeterValidationMiddleware{logger: logger, next: next}
	}
}
func (l greeterValidationMiddleware) Hello(ctx context.Context, request *HelloRequest) (response *HelloResponse, err error) {
	if err := request.Validate(); err != nil {
		l.logger.Log("message", "request validation failed", "method", "Hello", "error", err)
		return nil, err
	}
	response, err = l.next.Hello(ctx, request)
	if err != nil {
		return nil, err
	}
	err = response.Validate()
	if err != nil {
		l.logger.Log("message", "response validation failed", "method", "Hello", "error", err)
		return nil, err
	}
	return response, nil
}

func (l greeterValidationMiddleware) Goodbye(ctx context.Context, request *GoodbyeRequest) (response *GoodbyeResponse, err error) {
	if err := request.Validate(); err != nil {
		l.logger.Log("message", "request validation failed", "method", "Goodbye", "error", err)
		return nil, err
	}
	response, err = l.next.Goodbye(ctx, request)
	if err != nil {
		return nil, err
	}
	err = response.Validate()
	if err != nil {
		l.logger.Log("message", "response validation failed", "method", "Goodbye", "error", err)
		return nil, err
	}
	return response, nil
}

type greeterRecoveryMiddleware struct {
	logger kitlog.Logger
	next   GreeterServer
	UnimplementedGreeterServer
}

// GreeterRecoveryMiddleware takes a logger as a dependency
// and returns a GreeterServer Middleware.
func GreeterRecoveryMiddleware(logger kitlog.Logger) GreeterMiddleware {
	return func(next GreeterServer) GreeterServer {
		return &greeterRecoveryMiddleware{logger: logger, next: next}
	}
}
func (l greeterRecoveryMiddleware) Hello(ctx context.Context, request *HelloRequest) (response *HelloResponse, err error) {
	defer func() {
		if r := recover(); r != nil {
			l.logger.Log(
				"method", "Hello",
				"message", r)
			err = fmt.Errorf("%v", r)
		}
	}()
	return l.next.Hello(ctx, request)
}
func (l greeterRecoveryMiddleware) Goodbye(ctx context.Context, request *GoodbyeRequest) (response *GoodbyeResponse, err error) {
	defer func() {
		if r := recover(); r != nil {
			l.logger.Log(
				"method", "Goodbye",
				"message", r)
			err = fmt.Errorf("%v", r)
		}
	}()
	return l.next.Goodbye(ctx, request)
}

////////////////////////////////////////////////////////
// Go-kit endpoints for Greeter service
////////////////////////////////////////////////////////

//GreeterEndpoints stores all the enpoints of the service
type GreeterEndpoints struct {
	HelloEndpoint   kitendpoint.Endpoint
	GoodbyeEndpoint kitendpoint.Endpoint
}

func makeGreeterHelloEndpoint(handler GreeterServer) kitendpoint.Endpoint {
	return func(ctx context.Context, r interface{}) (interface{}, error) {
		request := r.(*HelloRequest)
		response, err := handler.Hello(ctx, request)
		return response, err
	}
}

func makeGreeterGoodbyeEndpoint(handler GreeterServer) kitendpoint.Endpoint {
	return func(ctx context.Context, r interface{}) (interface{}, error) {
		request := r.(*GoodbyeRequest)
		response, err := handler.Goodbye(ctx, request)
		return response, err
	}
}

// New returns a Endpoints struct that wraps the provided service, and wires in all of the
// expected endpoint middlewares
func NewGreeterEndpoints(handler GreeterServer, middlewares map[string][]kitendpoint.Middleware) GreeterEndpoints {
	endpoints := GreeterEndpoints{
		HelloEndpoint:   makeGreeterHelloEndpoint(handler),
		GoodbyeEndpoint: makeGreeterGoodbyeEndpoint(handler),
	}

	for _, middleware := range middlewares["Hello"] {
		endpoints.HelloEndpoint = middleware(endpoints.HelloEndpoint)
	}

	for _, middleware := range middlewares["Goodbye"] {
		endpoints.GoodbyeEndpoint = middleware(endpoints.GoodbyeEndpoint)
	}

	return endpoints
}

/////////////////////////////////////////////////////////////
// Go-kit grpc transport for Greeter service
/////////////////////////////////////////////////////////////

//GreeterRequestDecoder empty request decoder just returns the same request
func GreeterRequestDecoder(ctx context.Context, r interface{}) (interface{}, error) {
	return r, nil
}

//GreeterResponseEncoder empty response encoder just returns the same response
func GreeterResponseEncoder(_ context.Context, r interface{}) (interface{}, error) {
	return r, nil
}

type greeterGrpcServer struct {
	hellotransport   kitgrpc.Handler
	goodbyetransport kitgrpc.Handler
	UnimplementedGreeterServer
}

// implement GreeterServer Interface
//Hello implementation
func (s *greeterGrpcServer) Hello(ctx context.Context, r *HelloRequest) (*HelloResponse, error) {
	_, response, err := s.hellotransport.ServeGRPC(ctx, r)
	if err != nil {
		return nil, err
	}
	return response.(*HelloResponse), nil
}

//Goodbye implementation
func (s *greeterGrpcServer) Goodbye(ctx context.Context, r *GoodbyeRequest) (*GoodbyeResponse, error) {
	_, response, err := s.goodbyetransport.ServeGRPC(ctx, r)
	if err != nil {
		return nil, err
	}
	return response.(*GoodbyeResponse), nil
}

//NewGRPCServer create new grpc server
func NewGreeterGRPCServer(endpoints GreeterEndpoints, options map[string][]kitgrpc.ServerOption) GreeterServer {
	return &greeterGrpcServer{
		hellotransport: kitgrpc.NewServer(
			endpoints.HelloEndpoint,
			GreeterRequestDecoder,
			GreeterResponseEncoder,
			options["Hello"]...,
		),
		goodbyetransport: kitgrpc.NewServer(
			endpoints.GoodbyeEndpoint,
			GreeterRequestDecoder,
			GreeterResponseEncoder,
			options["Goodbye"]...,
		),
	}
}

/////////////////////////////////////////////////////////////////////
// Go-kit grpc main helper functions Greeter service
/////////////////////////////////////////////////////////////////////

func RunGreeterServer(logger, errorLogger kitlog.Logger, grpcAddr, httpAddr, debugAddr string, handler GreeterServer, middlewares map[string][]kitendpoint.Middleware) {
	endpoints := NewGreeterEndpoints(handler, middlewares)
	group := greeterCreateService(endpoints, logger, errorLogger, grpcAddr, httpAddr)
	initGreeterMetricsEndpoint(debugAddr, logger, errorLogger, group)
	initGreeterCancelInterrupt(group)
	logger.Log("exit", group.Run())
}

func RunGreeterServerWithDefaults(logger, errorLogger kitlog.Logger, grpcAddr, httpAddr, debugAddr string, handler GreeterServer) {
	middlewares := GetGreeterServiceMiddlewares(logger)
	for _, middleware := range middlewares {
		handler = middleware(handler)
	}
	RunGreeterServer(logger, errorLogger, grpcAddr, httpAddr, debugAddr, handler, nil)
}

func GetGreeterClient(address string, isInsecure bool, timeout time.Duration) (GreeterClient, *grpc.ClientConn, error) {
	var conn *grpc.ClientConn
	var err error
	ctx, cancel := context.WithTimeout(context.Background(), timeout*time.Second)
	defer cancel()

	if isInsecure {
		conn, err = grpc.DialContext(ctx, address, grpc.WithTransportCredentials(insecure.NewCredentials()))
	} else {
		conn, err = grpc.DialContext(ctx, address)
	}

	if err != nil {
		return nil, nil, err
	}
	return NewGreeterClient(conn), conn, nil
}

func GetGreeterServiceMiddlewares(logger kitlog.Logger) (middlewares []GreeterMiddleware) {
	middlewares = []GreeterMiddleware{}
	middlewares = append(middlewares, GreeterLoggingMiddleware(logger))
	middlewares = append(middlewares, GreeterValidationMiddleware(logger))
	middlewares = append(middlewares, GreeterRecoveryMiddleware(logger))
	return middlewares
}

func greeterCreateService(endpoints GreeterEndpoints, logger, errorLogger kitlog.Logger, grpcAddr, httpAddr string) (g *group.Group) {
	g = &group.Group{}

	initGreeterGRPCHandler(endpoints, logger, errorLogger, grpcAddr, g)
	initGreeterHTTPHandler(endpoints, logger, errorLogger, grpcAddr, httpAddr, g)
	return g
}

func defaultGreeterGRPCOptions(errorLogger kitlog.Logger) map[string][]kitgrpc.ServerOption {
	options := map[string][]kitgrpc.ServerOption{
		"Hello":   {kitgrpc.ServerErrorLogger(errorLogger)},
		"Goodbye": {kitgrpc.ServerErrorLogger(errorLogger)},
	}
	return options
}

func initGreeterGRPCHandler(endpoints GreeterEndpoints, logger, errorLogger kitlog.Logger, serviceAddr string, g *group.Group) {
	options := defaultGreeterGRPCOptions(errorLogger)

	grpcServer := NewGreeterGRPCServer(endpoints, options)
	listener, err := net.Listen("tcp", serviceAddr)
	if err != nil {
		errorLogger.Log("transport", "gRPC", "during", "Listen", "err", err)
	}

	g.Add(func() error {
		logger.Log("transport", "gRPC", "addr", serviceAddr)
		baseServer := grpc.NewServer()
		RegisterGreeterServer(baseServer, grpcServer)
		return baseServer.Serve(listener)
	}, func(error) {
		listener.Close()
	})
}

func initGreeterHTTPHandler(endpoints GreeterEndpoints, logger, errorLogger kitlog.Logger, grpcAddr, httpAddr string, g *group.Group) {
	g.Add(func() error {
		logger.Log("transport", "http", "addr", httpAddr)
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		mux := runtime.NewServeMux()
		opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}
		err := RegisterGreeterHandlerFromEndpoint(ctx, mux, grpcAddr, opts)
		if err != nil {
			errorLogger.Log("transport", "http", "during", "RegisterGreeterHandlerFromEndpoint", "err", err)
			return err
		}
		return http.ListenAndServe(httpAddr, mux)
	}, func(err error) {
		errorLogger.Log("transport", "http", "during", "ListenAndServe", "err", err)
	})
}

func initGreeterMetricsEndpoint(debugAddr string, logger, errorLogger kitlog.Logger, g *group.Group) {
	http.DefaultServeMux.Handle("/metrics", promhttp.Handler())
	debugListener, err := net.Listen("tcp", debugAddr)
	if err != nil {
		errorLogger.Log("transport", "debug/HTTP", "during", "Listen", "err", err)
	}
	g.Add(func() error {
		logger.Log("transport", "debug/HTTP", "addr", debugAddr)
		return http.Serve(debugListener, http.DefaultServeMux)
	}, func(error) {
		debugListener.Close()
	})
}

func initGreeterCancelInterrupt(g *group.Group) {
	cancelInterrupt := make(chan struct{})
	g.Add(func() error {
		c := make(chan os.Signal, 1)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		select {
		case sig := <-c:
			return fmt.Errorf("received signal %s", sig)
		case <-cancelInterrupt:
			return nil
		}
	}, func(error) {
		close(cancelInterrupt)
	})
}
